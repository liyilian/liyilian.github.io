[{"title":"iPhoneX适配","date":"2017-10-23T05:45:25.000Z","path":"2017/10/23/iPhoneX/","text":"一. iPhone手机各版本尺寸 二. iPhoneX手机具体尺寸大小","tags":[{"name":"iOS","slug":"iOS","permalink":"http://baidu.com/tags/iOS/"},{"name":"iPhoneX","slug":"iPhoneX","permalink":"http://baidu.com/tags/iPhoneX/"}]},{"title":"svn","date":"2016-07-23T05:45:25.000Z","path":"2016/07/23/SVN/","text":"一. 查看当前文件下修改1svn status 二. 提交当前文件夹下修改文件12a. svn ci -m &quot;还原confi.h文件 &quot; Additions/heads/Config.h (单个文件)b. svn ci -m “添加多个文件 “空格” 间隔 text1.h text2.h (多个文件) 三. 提交当前文件夹以及文件夹文件123a. svn add APP/Classes/BankTask/TestFiles --forceb. svn ci -m “add 新文件夹” APP/Classes/BankTask/TestFilesc. 如果是xcode直接拖进代码，还需要提交xcode路径，直接把代码文件放到对应的目录下是没有路径的 (切记) 四. 删除文件或者文件夹 第一种 121. svn delete APP/Classes/BankTask/TestThreeFiles 2. svn ci -m &quot;删除TestThreeFiles文件&quot; APP/Classes/BankTask/TestThreeFiles 第二种 11. svn (del, remove, rm) 没搞明白 五. 更新版本简写： 1svn up 123a. svn update 如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本b. svn update -r 200 test.php(将版本库中的文件test.php还原到版本200)c. svn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved，最后再提交commit) 六. 恢复本地修改1svn revert path : 恢复原始未改变的工作副本文件 (恢复大部份的本地修改) 注意: 本子命令不会存取网络，并且会解除冲突的状况。但 是它不会恢复被删除的目录 七. 解决冲突1svn resolved path : 移除工作副本的目录或文件的“冲突”状态。 注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的相关文件，然后让 PATH 可以再次提交。 (1) 冲突信息 121. D C removed_directory . 2. local unversioned, incoming add upon update (2) 解决方案 121. svn resolve --accept working (removed_directory)(path) 2. svn revert removed_directory 八. 将文件checkout到本地目录12a. svn checkout svn://192.168.1.1/pro/domain 简写：svn cob. svn checkout -r791)(指定版本) path 九. 查看文件详细信息1svn info path 例如：svn info test.php 十. 比较诧异简写： 1svn di 1svn diff path(将修改的文件与基础版本比较) 例如：svn diff test.php 1svn diff -r m:n path(对版本m和版本n比较差异) 例如：svn diff -r 200:201 test.php 十一. 将两个版本之间的差异合并到当前文件1a. svn merge -r m:n path 例如：svn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下） 一、将文件checkout到本地目录1svn checkout path（path是服务器上的目录） 例如：svn checkout svn://192.168.1.1/pro/domain 简写： 1svn co 二、往版本库中添加新的文件1svn add file 例如：svn add test.php(添加test.php) 1svn add *.php(添加当前目录下所有的php文件) 三、将改动的文件提交到版本库1svn commit -m &quot;LogMessage&quot; [-N] [--no-unlock] PATH(如果选择了保持锁，就使用--no-unlock开关) 例如：svn commit -m “add test file for my test” test.php 1简写：svn ci 四、加锁/解锁1svn lock -m &quot;LockMessage&quot; [--force] PATH 例如：svn lock -m “lock test file” test.php 1svn unlock PATH 五、更新到某个版本1svn update -r m path 例如: svn update如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。 svn update -r 200 test.php(将版本库中的文件test.php还原到版本200) svn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved，最后再提交commit) 简写： 1svn up 六、查看文件或者目录状态 svn status path（目录下的文件和子目录的状态，正常状态不显示） ?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定 svn status -v path(显示文件和子目录状态) 第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。 注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。 简写： 1svn st 七、删除文件1svn delete path -m &quot;delete test fle&quot; 例如：svn delete svn://192.168.1.1/pro/domain/test.php -m “delete test file”或者直接svn delete test.php 然后再svn ci -m ‘delete test file‘，推荐使用这种 简写： 1svn (del, remove, rm) 八、查看日志1svn log path 例如：svn log test.php 显示这个文件的所有修改记录，及其版本号的变化 九、查看文件详细信息1svn info path 例如：svn info test.php 十、比较差异1svn diff path(将修改的文件与基础版本比较) 例如：svn diff test.php 1svn diff -r m:n path(对版本m和版本n比较差异) 例如：svn diff -r 200:201 test.php 简写： 1svn di 十一、将两个版本之间的差异合并到当前文件1svn merge -r m:n path 例如：svn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下） 十二、SVN 帮助12svn helpsvn help ci 以上是常用命令，下面写几个不经常用的 十三、版本库下的文件和目录列表1svn list path 显示path目录下的所有属于版本库的文件和目录 简写： 1svn ls 十四、创建纳入版本控制下的新目录1svn mkdir: 创建纳入版本控制下的新目录。 用法: mkdir PATH… mkdir URL… 创建版本控制的目录。 每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增调度，以待下一次的提交。 每个以URL指定的目录，都会透过立即提交于仓库中创建。在这两个情况下，所有的中间目录都必须事先存在。 十五、恢复本地修改1svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。 revert:用法: revert PATH… 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录 十六、代码库URL变更1svn switch (sw): 更新工作副本至不同的URL。 用法: switch URL [PATH] switch –relocate FROM TO [PATH…] 更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的方法。 改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动 (比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用这个命令更新工作副本与仓库的对应关系。 十七、解决冲突1svn resolved: 移除工作副本的目录或文件的“冲突”状态。 用法: resolved PATH… 注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的相关文件，然后让 PATH 可以再次提交。 十八、输出指定文件或URL的内容。12svn cat 目标[@版本]...如果指定了版本，将从指定的版本开始查找。svn cat -r PREV filename &gt; filename (PREV 是上一版本,也可以写具体版本号,这样输出结果是可以提交的)","tags":[{"name":"iOS","slug":"iOS","permalink":"http://baidu.com/tags/iOS/"},{"name":"svn","slug":"svn","permalink":"http://baidu.com/tags/svn/"}]},{"title":"markdown语法","date":"2016-06-16T01:21:59.000Z","path":"2016/06/16/markdown/","text":"markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 一、标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题二、字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 1234**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 这是加粗的文字这是倾斜的文字这是斜体加粗的文字这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。示例： 1234-------******** 效果如下：可以看到，显示效果是一样的。 五、图片语法： 1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 效果如下： 上传本地图片直接点击导航栏的图片标志，选择图片即可 六、超链接语法： 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下： 简书百度 注：markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 123&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 效果如下： 超链接名例简书 七、列表 无序列表 语法：无序列表用 - + * 任何一种都可以 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表 语法：数字加点 123451. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 12345678910111213141516+ 一级无序列表内容 + 二级无序列表内容 + 二级无序列表内容 + 二级无序列表内容+ 一级无序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容1. 一级有序列表内容 + 二级无序列表内容 + 二级无序列表内容 + 二级无序列表内容2. 一级有序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容 效果如下： 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 八、表格语法： 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九、代码语法： 单行代码：代码之间分别用一个反引号包起来 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 12345(```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 单行代码 1`create database hero;` 代码块 123456(```) function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;; &#125; fun();(```) 效果如下： 单行代码 create database hero; 代码块 1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun();","tags":[{"name":"js","slug":"js","permalink":"http://baidu.com/tags/js/"},{"name":"markdown","slug":"markdown","permalink":"http://baidu.com/tags/markdown/"}]},{"title":"cocoaPods的使用","date":"2016-05-19T06:21:59.000Z","path":"2016/05/19/cocoaPods/","text":"一、什么是CocoaPods每种语言发展到一个阶段，就会出现相应的依赖管理工具，例如 Java 语言的 Maven，nodejs 的 npm。随着 iOS 开发者的增多，业界也出现了为 iOS 程序提供依赖管理的工具，它的名字叫做：CocoaPods。CocoaPods项目的源码 在 Github 上管理。该项目开始于 2011 年 8 月 12 日，经过多年发展，现在已经成为 iOS 开发事实上的依赖管理标准工具。开发 iOS 项目不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。 二、为什么要使用CocoaPods在使用CocoaPods之前，开发项目需要用到第三方开源库的时候，我们需要 1.把开源库的源代码复制到项目中 2.添加一些依赖框架和动态库 3.设置-ObjC，-fno-objc-arc等参数 4.管理他们的更新 在使用CocoaPods后，我们只需要把用到的开源库放到一个名为Podfile的文件中，然后执行pod install就可以了，Cocoapods就会自动将这些第三方开源库的源码下载下来，并且为我们的工程设置好响应的系统依赖和编译参数。 三、CocoaPods的原理CocoaPods的原理是将所有的依赖库都放到另一个名为Pods的项目中，然后让主项目依赖Pods项目，这样，源码管理工作都从主项目移到了Pods项目中。Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖这个.a文件即可。 四、CocoaPods的安装1. 设置ruby的软件源1234567$ gem sources -l #(查看当前ruby的源)$ gem sources --remove https://rubygems.org/ #(移除当前ruby的源)$ gem sources -a https://gems.ruby-china.org/(原来的淘宝镜像 https://ruby.taobao.org/已经不能用了)$ gem sources -l #(再次查看当前ruby的源) 如果Terminal输出： CURRENT SOURCES https://gems.ruby-china.org/ 可以用gem sources -l 来检查使用替换镜像位置成功，结果应该只有 https://gems.ruby-china.org/ 才对。 就证明ruby的软件源已经设置OK了。 2. 设置gem为最新版本1$ sudo gem update --system 升级成功后会提示: Latest version currently installed. Aborting. 3. 执行安装CocoaPods命令 $ sudo gem install cocoapods // Mac OS X 10.11前 输入这一条 $ sudo gem install -n /usr/local/bin cocoapods //Mac OS X 10.11后 输入这一条 成功后 $ pod setup 这条命令是将Github上的开源库都托管都安装Podspec索引安装到到本 地, 这一步, 很慢….. 很慢………. 很慢…………… 大约要下载200M的文件,偏偏下载速度出奇的慢,本人保持在30K/S,大约2个小时,关键是没有任何进度条显示,就这样傻乎乎的卡死在这里 五、Cocoapods的使用1. 引入第三方库到项目中 创建一个工程，并创建podfile配置文件 先用cd进入到工程中去输入指令vim podfile创建podfile文件，然后按i进入到编辑模式配置文件固定语句如下： 1234platform :ios, &apos;8.0&apos;target &apos;TargetName&apos; dopod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos;end 然后按esc，接着按” : “ 然后输入wq 按回车键 返回终端界面， 输入终端命令 1$ pod install 意思是初始化，所以每次添加新的库的时候，之前的指令都不能删除，它只会添加指令中有的库。 如果发现安装cocoapods之后，初始化pod时在receive object是正常情况 需要耐心等待。 2. 更新CocoaPods中的第三方们。 第三方库们都有人在维护升级，我们需要隔断时间就要更新下我们工程中第三方库的版本。只需要终端输入命令 1$ pod update 就可以了。 如果遇到podinstall或者pod update慢的问题，原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下： 12$ pod install --verbose --no-repo-update$ pod update --verbose --no-repo-update 3. 删除CocoaPods中的某些第三方们。当我们需要去掉某个第三方库时，只需要在Podfile删除该引入该库的语句，然后执行 1$ pod update或者 $ pod install 就可以了。 4. 将CocoaPods从项目中删除如果你在以后的使用过程中不想用CocoaPods了怎么办？很简单，把多出来的东西们都删掉就可以了，不过为了项目正常运行，你需要手动导入已经使用的第三方们哦。 5. 升级CocoaPods升级CocoaPods版本的命令和安装CocoaPods的命令一样，都是 1$ sudo gem install cocoapods。 如果老版本升级cocoapods的时候提示Operation not permitted - /usr/bin/xcodeproj，改用命令 1$ sudo gem install -n /usr/local/bin cocoapods --pre 就可以了。 6. 卸载CocoaPods卸载CocoaPods的命令是： 1$ sudo gem uninstall cocoapods 六、 文章的最后附上一些常用指令1. pod安装12345678# 添加源$ sudo gem sources -a https://ruby.taobao.org/# 删除源$ sudo gem sources -r https://rubygems.org/# 安装$ sudo gem install cocoapods# 设置$ pod setup 2. gem常用命令123456789101112# 查看版本$ gem --version# 清除过期的gem$ sudo gem cleanup# 安装包$ sudo gem install cocoapods# 删除包$ gem uninstall cocoapods# 更新包$ sudo gem update# 列出本地安装的包$ gem list 3. pod命令123456789101112# 第一次使用安装框架 //只用安装一次,之后使用 添加删除都用 pod update --no-repo-update $ pod install# 安装框架，不更新本地索引，速度快$ pod install --no-repo-update # 今后升级、添加、删除框架，或者框架不好用$ pod update# 更新框架，不更新本地索引，速度快$ pod update --no-repo-update # 搜索框架$ pod search XXX# 帮助$ pod --help","tags":[{"name":"iOS","slug":"iOS","permalink":"http://baidu.com/tags/iOS/"},{"name":"cocoaPods","slug":"cocoaPods","permalink":"http://baidu.com/tags/cocoaPods/"}]},{"title":"Native.js","date":"2016-05-17T09:53:15.000Z","path":"2016/05/17/Native-js/","text":"Native.js技术，简称NJS，是一种将手机操作系统的原生对象转义，映射为JS对象，在JS里编写原生代码的技术。如果说Node.js把js扩展到服务器世界，那么Native.js则把js扩展到手机App的原生世界。HTML/JS/Css全部语法只有7万多，而原生语法有几十万，Native.js大幅提升了HTML5的能力。NJS突破了浏览器的功能限制，也不再需要像Hybrid那样由原生语言开发插件才能补足浏览器欠缺的功能。NJS编写的代码，最终需要在HBuilder里打包发行为App安装包，或者在支持Native.js技术的浏览器里运行。目前Native.js技术不能在普通手机浏览器里直接运行。 NJS大幅扩展了HTML5的能力范围，原本只有原生或Hybrid App的原生插件才能实现的功能如今可以使用JS实现。 NJS大幅提升了App开发效率，将iOS、Android、Web的3个工程师组队才能完成的App，变为1个web工程师就搞定。 NJS不再需要配置原生开发和编译环境，调试、打包均在HBuilder里进行。没有mac和xcode一样可以开发iOS应用。 如果不熟悉原生API也没关系，我们汇总了很多NJS的代码示例，复制粘贴就可以用。http://ask.dcloud.net.cn/article/114 再次强调，Native.js不是一个js库，不需要下载引入到页面的script中，也不像nodejs那样有单独的运行环境，Native.js的运行环境是集成在5+runtime里的，使用HBuilder打包的app或流应用都可以直接使用Native.js。","tags":[{"name":"Native","slug":"Native","permalink":"http://baidu.com/tags/Native/"}]},{"title":"react native的优缺点","date":"2016-05-17T07:29:03.000Z","path":"2016/05/17/reactNative/","text":"React Native 优缺点分析经过一长篇的讨论，其实 React Native 的优缺点已经不难分析了，这里简单总结一下： 优点 复用了 React 的思想，有利于前端开发者涉足移动端。 能够利用 JavaScript 动态更新的特性，快速迭代。 相比于原生平台，开发速度更快，相比于 Hybrid 框架，性能更好 缺点 做不到 Write once, Run everywhere，也就是说开发者依然需要为 iOS 和 Android 平台提供两套不同的代码，比如参考官方文档可以发现不少组件和API都区分了 Android 和 iOS 版本。即使是共用组件，也会有平台独享的函数。 不能做到完全屏蔽 iOS 端或 Android 的细节，前端开发者必须对原生平台有所了解。加重了学习成本。对于移动端开发者来说，完全不具备用 React Native 开发的能力。 由于 Objective-C 与 JavaScript 之间切换存在固定的时间开销，所以性能必定不及原生。比如目前的官方版本无法做到 UItableview(ListView) 的视图重用，因为滑动过程中，视图重用需要在异步线程中执行，速度太慢。这也就导致随着 Cell 数量的增加，占用的内存也线性增加。 综上，我对 React Native 的定位是： 利用脚本语言进行原生平台开发的一次成功尝试，降低了前端开发者入门移动端的门槛，一定业务场景下具有独特的优势，几乎不可能取代原生平台开发。","tags":[{"name":"react native","slug":"react-native","permalink":"http://baidu.com/tags/react-native/"}]},{"title":"cocoaPods导入环信Hyphenate时出的问题","date":"2016-05-12T09:55:22.000Z","path":"2016/05/12/easemob/","text":"出现问题 1234567Apin-iOS:Apin2017 aipinji$ pod installAnalyzing dependencies[!] Unable to satisfy the following requirements:- `Hyphenate (~&gt; 3.3.1)` required by `Podfile`Specs satisfying the `Hyphenate (~&gt; 3.3.1)` dependency were found, but they required a higher minimum deployment target. 解决方法 12345678910111213141516171819202122232425platform :ios,&apos;8.0&apos;target &quot;Apin&quot; dopod &apos;pop&apos;, &apos;~&gt; 1.0&apos;pod &apos;Masonry&apos;pod &apos;IQKeyboardManager&apos;pod &apos;YYModel&apos;pod &apos;Bugly&apos;, &apos;~&gt; 2.4.2&apos;pod &apos;UMengAnalytics-NO-IDFA&apos;, &apos;~&gt; 4.1.9&apos;pod &apos;MBProgressHUD&apos;, &apos;~&gt; 0.9&apos;pod &apos;PKRevealController&apos;pod &apos;AMap3DMap&apos;pod &apos;AMapSearch&apos;pod &apos;TZImagePickerController&apos;pod &apos;MJRefresh&apos;pod &apos;SDWebImage&apos;, &apos;~&gt;3.8&apos;pod &apos;AFNetworking&apos;, &apos;~&gt; 3.1.0&apos;pod &apos;WebViewJavascriptBridge&apos;, &apos;~&gt; 5.0&apos;pod &apos;UMengUShare/UI&apos;pod &apos;UMengUShare/Social/Sina&apos;pod &apos;UMengUShare/Social/WeChat&apos;pod &apos;UMengUShare/Social/QQ&apos;pod &apos;SDCycleScrollView&apos;,&apos;~&gt; 1.64&apos;pod &apos;Hyphenate&apos;, &apos;~&gt; 3.3.1&apos;pod &apos;EaseUI&apos;, :git =&gt; &apos;https://github.com/easemob/easeui-ios-hyphenate-cocoapods.git&apos;end 出现问题 12345678Apin-iOS:Apin2017 aipinji$ pod installAnalyzing dependenciesPre-downloading: `EaseUI` from `https://github.com/easemob/easeui-ios-hyphenate-cocoapods.git`[!] Unable to satisfy the following requirements:- `MBProgressHUD` required by `Podfile`- `MBProgressHUD (= 1.0.0)` required by `Podfile.lock`- `MBProgressHUD (~&gt; 0.9)` required by `MWPhotoBrowser (2.1.1)` 解决方法 1pod &apos;MBProgressHUD&apos;, &apos;~&gt; 0.9&apos;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://baidu.com/tags/iOS/"},{"name":"cocoaPods","slug":"cocoaPods","permalink":"http://baidu.com/tags/cocoaPods/"},{"name":"Hyphenate","slug":"Hyphenate","permalink":"http://baidu.com/tags/Hyphenate/"}]},{"title":"CoreBlueTooth","date":"2016-05-10T02:02:01.000Z","path":"2016/05/10/CoreBlueTooth/","text":"iOS之蓝牙简介和使用(三)：CoreBlueToothCoreBlueTooth简介： 可用于第三方蓝牙设备交互，设备必须支持蓝牙4.0 iPhone的设备必须是4S或者更新 iPad设备必须是iPad mini或者更新 iOS的系统必须是iOS 6或者更新 蓝牙4.0以低功耗著称，所以一般被称为BLE（bluetooth low energy） 使用模拟器调试 Xcode 4.6 iOS 6.1 应用场景 运动手环 智能家居 拉卡拉蓝牙刷卡器 核心概念 CBCentralManager：中心设备（用来连接到外部设备的管家） CBPeripheralManager：外部设备（第三方的蓝牙4.0设备）这里写图片描述 开发步骤 建立中心管家 12// 1. 创建中心管家,并且设置代理self.cmgr = [[CBCentralManager alloc]initWithDelegate:self queue:nil]; 扫描外设（discover） 123456789101112// 2. 在代理方法中扫描外部设备 /** * scanForPeripheralsWithServices ：如果传入指定的数组，那么就只会扫描数组中对应ID的设备 * 如果传入nil，那么就是扫描所有可以发现的设备 * 扫描完外部设备就会通知CBCentralManager的代理 */ - (void)centralManagerDidUpdateState:(CBCentralManager *)central&#123; if ([central state] == CBCentralManagerStatePoweredOn) &#123; [self.cmgr scanForPeripheralsWithServices:nil options:nil]; &#125;&#125; 123456789101112/** * 发现外部设备，每发现一个就会调用这个方法 * 所以可以使用一个数组来存储每次扫描完成的数组 */- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *,id&gt; *)advertisementData RSSI:(NSNumber *)RSSI&#123; // 有可能会导致重复添加扫描到的外设 // 所以需要先判断数组中是否包含这个外设 if(![self.peripherals containsObject:peripheral])&#123; [self.peripherals addObject:peripheral]; &#125;&#125; 连接外设 1234567891011121314/** * 模拟开始连接方法 */- (void)start&#123; // 3. 连接外设 for (CBPeripheral *ppl in self.peripherals) &#123; // 扫描外设的服务 // 这个操作应该交给外设的代理方法来做 // 设置代理 ppl.delegate = self; [self.cmgr connectPeripheral:ppl options:nil]; &#125;&#125; 扫描外设中的服务和特征 服务和特征的关系 每个蓝牙4.0的设备都是通过服务和特征来展示自己的，一个设备必然包含一个或多个服务，每个服务下面又包含若干个特征。 12345678/** * 连接外设成功调用 */- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123; // 查找外设服务 [peripheral discoverServices:nil];&#125; 1234567891011121314/** * 发现服务就会调用代理方法 * * @param peripheral 外设 */- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error&#123; // 扫描到设备的所有服务 NSArray *services = peripheral.services; // 根据服务再次扫描每个服务对应的特征 for (CBService *ses in services) &#123; [peripheral discoverCharacteristics:nil forService:ses]; &#125;&#125; 与外设做数据交互 在指定的特征下做相应的操作 123456789101112131415/** * 发现服务对应的特征 */- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error&#123; // 服务对应的特征 NSArray *ctcs = service.characteristics; // 遍历所有的特征 for (CBCharacteristic *character in ctcs) &#123; // 根据特征的唯一标示过滤 if ([character.UUID.UUIDString isEqualToString:@&quot;XMG&quot;]) &#123; NSLog(@&quot;可以吃饭了&quot;); &#125; &#125;&#125; 断开连接 12345678910/** * 断开连接 */- (void)stop&#123; // 断开所有连接上的外设 for (CBPeripheral *per in self.peripherals) &#123; [self.cmgr cancelPeripheralConnection:per]; &#125;&#125; 原文地址：http://blog.csdn.net/wzc10101415/article/details/55101405","tags":[{"name":"iOS","slug":"iOS","permalink":"http://baidu.com/tags/iOS/"},{"name":"蓝牙","slug":"蓝牙","permalink":"http://baidu.com/tags/蓝牙/"},{"name":"CoreBlueTooth","slug":"CoreBlueTooth","permalink":"http://baidu.com/tags/CoreBlueTooth/"}]},{"title":"iOS之蓝牙简介和使用(二)：MutipeerConnectivity","date":"2016-05-09T09:52:31.000Z","path":"2016/05/09/MutipeerConnectivity/","text":"iOS之蓝牙简介和使用(二)：MutipeerConnectivity蓝牙mutipeerConnectivity简介 iOS 7引入的一个全新框架 多点连接 替代GameKit框架 多用于文件的传输 iOS设备不联网也能跟附近的人聊天 123* FireChat* See You Around* 以上近场聊天App都是基于mutipeerConnectivity框架 搜索和传输的方式 1234* 双方WIFI和蓝牙都没有打开：无法实现* 双方都开启蓝牙：通过蓝牙发现和传输* 双方都开启WIFI：通过WIFI Direct发现和传输，速度接近AirDrop* 双方同时开启了WIFI和蓝牙：模拟AirDrop，通过低功耗蓝牙技术扫描发现握手，然后通过WIFI Direct传输 案例界面搭建连接设备 创建MCSession对象用于存放当前连接的会话 1234// 创建MCSession对象// initWithPeer：设备的ID// 用于存放当前的连接的会话self.mc_Session = [ [MCSession alloc]initWithPeer:[[MCPeerID alloc] initWithDisplayName:[UIDevice currentDevice].name]]; 开启广播对象，通知正在搜索的设备他们是可用的 12345678910111213141516171819202122/** * 只要开启了可被搜索的广播，那么连接蓝牙按钮就不可点 */- (IBAction)foundConnect:(id)sender &#123; UISwitch *switchBtn = (UISwitch *)sender; if (switchBtn.isOn) &#123; // 广播对象，告诉其它的设备他们是可用的 if (self.advertiserAssistant == nil) &#123; // 创建广播对象 // initWithServiceType： 广播类型的标示（因为广播可能比较多，所以最好每个广播绑定一个唯一标示） // session：当前会话 // discoveryInfo： 广播信息 self.advertiserAssistant = [[MCAdvertiserAssistant alloc] initWithServiceType:SERVICE_TYPE discoveryInfo:nil session:self.mc_Session]; &#125; // 开启广播 [self.advertiserAssistant start]; self.connectBT.enabled = NO; &#125;else&#123; self.connectBT.enabled = YES; &#125;&#125; 开始搜索蓝牙设备 12345678- (IBAction)connectBlueTooth &#123; // 创建搜索蓝牙设备控制器 MCBrowserViewController *mbVC = [[MCBrowserViewController alloc]initWithServiceType:SERVICE_TYPE session:self.mc_Session]; // 设置控制器代理 mbVC.delegate = self; // 跳转到搜索控制器 [self presentViewController:mbVC animated:YES completion:nil];&#125; 选择数据12345678910111213- (IBAction)selectImage &#123; // 1. 创建图片选择器 UIImagePickerController *imgPicker = [[UIImagePickerController alloc]init]; // 2. 判断图片选择器是否可用 if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeSavedPhotosAlbum]) &#123; // 选择器打开的类型 imgPicker.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum; // 设置代理 imgPicker.delegate = self; // 打开图片选择器 [self presentViewController:imgPicker animated:YES completion:nil]; &#125;&#125; 图片选择器代理中获取数据 123456789// 选择完毕调用- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info&#123;// NSLog(@&quot;info == %@&quot;,info); // 设置显示图片 self.showImage.image = info[UIImagePickerControllerOriginalImage]; // 隐藏图片显示器 [picker dismissViewControllerAnimated:YES completion:nil];&#125; 在搜索控制器的连接完成的代理方法中隐藏搜索控制器 12345678910/** * 连接完成 * * @param browserViewController 搜索控制器 */- (void)browserViewControllerDidFinish:(MCBrowserViewController *)browserViewController&#123; [browserViewController dismissViewControllerAnimated:YES completion:nil]; NSLog(@&quot;%s %d&quot;,__func__,__LINE__);&#125; 发送数据 实现搜索控制器的代理方法，获取连接上的设备ID 123456789101112131415161718#pragma mark - MCBrowserViewControllerDelegate/** * 连接成功 * * @param browserViewController 搜索控制器 * @param peerID 连接上的设备ID * @param info 连接的信息 * * @return YES ： 只发送连接上的用户 */- (BOOL)browserViewController:(MCBrowserViewController *)browserViewController shouldPresentNearbyPeer:(MCPeerID *)peerID withDiscoveryInfo:(nullable NSDictionary&lt;NSString *, NSString *&gt; *)info&#123; self.peerID = peerID; NSLog(@&quot;info == %@ peer = %@&quot;,info, peerID); return YES;&#125; 将图片发送给连接上的ID 1234567891011121314- (IBAction)sendImage &#123; // 获取图片 UIImage *image = self.showImage.image; // 将图片转换成NSData类型 NSData *data = UIImagePNGRepresentation(image); /** * 发送数据 * toPeers ： 发给的设备ID的数组 * withMode： 发送模式，是否是安全模式 */ if (self.peerID != nil) &#123; [self.mc_Session sendData:data toPeers:@[self.peerID] withMode:MCSessionSendDataUnreliable error:nil]; &#125;&#125; 接收数据 实现MCSession的代理方法接受数据 12345- (void)session:(MCSession *)session didReceiveData:(NSData *)data fromPeer:(MCPeerID *)peerID&#123; NSLog(@&quot;%s %d&quot;,__func__,__LINE__); NSLog(@&quot;data = %@ , peer = %@&quot;,data,peerID);&#125; 显示数据 在MCSeesion代理方法中设置获取过来的数据 12345678910111213// 接收的数据- (void)session:(MCSession *)session didReceiveData:(NSData *)data fromPeer:(MCPeerID *)peerID&#123; NSLog(@&quot;%s %d&quot;,__func__,__LINE__);// NSLog(@&quot;data = %@ , peer = %@&quot;,data,peerID); UIImage *image = [[UIImage alloc]initWithData:data]; if(image != nil)&#123; // 设置数据 dispatch_async(dispatch_get_main_queue(), ^&#123; self.showImage.image = image; &#125;); &#125;&#125; 原文地址：http://blog.csdn.net/wzc10101415/article/details/55101346","tags":[{"name":"iOS","slug":"iOS","permalink":"http://baidu.com/tags/iOS/"},{"name":"蓝牙","slug":"蓝牙","permalink":"http://baidu.com/tags/蓝牙/"},{"name":"MutipeerConnectivity","slug":"MutipeerConnectivity","permalink":"http://baidu.com/tags/MutipeerConnectivity/"}]},{"title":"iOS之蓝牙简介和使用(一)：GameKit","date":"2016-05-09T09:02:43.000Z","path":"2016/05/09/GameKit/","text":"iOS之蓝牙简介和使用(一)：GameKit蓝牙GameKit简介： 实现蓝牙设备之间的通讯 只能使用在iOS设备之间同一个应用内连接 从iOS7开始过期了 但是GameKit是最基本的蓝牙通讯框架 通过蓝牙可以实现文件的共享（仅限设备沙盒中的文件） 此框架一般用于游戏开发（比如五子棋对战） 开始案例简介： 使用蓝牙将两个iOS设备连接起来 搜索对方的设备 实现将手机中的图片发送给对方 界面的搭建：蓝牙互连： 搜索蓝牙设备 1234// 初始化链接蓝牙控制器 GKPeerPickerController *peerCtr = [[GKPeerPickerController alloc]init]; // 显示匹配到的蓝牙设备 [peerCtr show]; GKPeerPickerController最重要的两个代理 12345678910111213141516171819/** * 链接成功 * * @param picker 蓝牙控制器 * @param peerID 连接蓝牙的设备id * @param session 连接蓝牙的会话（通讯）用来传数据 */- (void)peerPickerController:(GKPeerPickerController *)picker didConnectPeer:(NSString *)peerID toSession:(GKSession *)session&#123; NSLog(@&quot;%s %d&quot;,__func__,__LINE__); // 隐藏蓝牙控制器 [picker dismiss];&#125;// 退出连接- (void)peerPickerControllerDidCancel: (GKPeerPickerController *)picker&#123; NSLog(@&quot;%s %d&quot;,__func__,__LINE__);&#125; 选择图片： 选择图片方法 1234567891011121314 // 选择图片- (IBAction)chooseImage &#123; // 1.初始化图片选择控制器 UIImagePickerController *imgPicker = [[UIImagePickerController alloc]init]; // 2.判断图库是否可用 if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeSavedPhotosAlbum]) &#123; // 3.设置图库打开的类型 imgPicker.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum; // 4. 设置代理 imgPicker.delegate = self; // 5. 打开图库 [self presentViewController:imgPicker animated:YES completion:nil]; &#125;&#125; 选择图片控制器的代理方法 1234567891011121314 /** * 图片选择完成调用 * * @param picker 图片选择控制器 * @param info 选择的信息 */- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info&#123; NSLog(@&quot;info == %@&quot;,info); // 设置选择的图片为当前的显示图片 self.showImageView.image = info[UIImagePickerControllerOriginalImage]; // 隐藏当前选择图片控制器 [picker dismissViewControllerAnimated:YES completion:nil];&#125; 图片相互发送： 需要在连接成功代理方法中存储当前的会话 12// 保存当前回话 self.m_Session = session; 发送图片方法 123456789101112131415161718 // 发送图片- (IBAction)sendImage &#123; // 拿到需要发送出去的图片 UIImage *image = self.showImageView.image; // 将图片转换成NSData类型 NSData *imgData = UIImagePNGRepresentation(image); /** * 发送数据给所有匹配上的用户 * * @param GKSendDataMode 数据发送的模式：（安全/不安全模式） * GKSendDataUnreliable : 不安全模式：就像发10个传单，传单直接往人群中砸过去，能不能收到不管 * GKSendDataReliable：安全模式：就像发10个传单，每一个传单都得发到路人的手上，才再发下一个传单 * @return */ [self.m_Session sendDataToAllPeers:imgData withDataMode:GKSendDataUnreliable error:nil];&#125; 设置图片： GameKit提供的接受数据是方法的回调 需要监听接收传递过来的数据 在连接成功代理方法中设置监听 12345/** 监听传递过来的数据 * setDataReceiveHandler: 由哪个对象来监听数据的接受 * withContext ： 监听需要传递的参数 */ [session setDataReceiveHandler:self withContext:nil]; 实现监听方法 只设置由谁监听传递过来的数据还是不足的，因为我们还是不能拿到传递过来的数据，进入监听方法的头文件可以看到 1// SEL = -receiveData:fromPeer:inSession:context: 所以我们必须实现这个方法才能拿到接收到的数据，这个回调方法方法在Xcode 7之前的版本的解释如图： 123456789101112131415 /** * 实现接收数据的回调方法 * * @param data 接收到的数据 * @param peer 传递数据的设备ID * @param session 当前回话 * @param context 注册监听传递过来的数据 */- (void) receiveData:(NSData *)data fromPeer:(NSString *)peer inSession: (GKSession *)session context:(void *)context&#123; // 因为传递过来的是图片，所以我们直接使用UIImage来接受 UIImage *image = [UIImage imageWithData:data]; // 设置图片 self.showImageView.image = image;&#125; 原文地址：http://blog.csdn.net/wzc10101415/article/details/55101321","tags":[{"name":"iOS","slug":"iOS","permalink":"http://baidu.com/tags/iOS/"},{"name":"蓝牙","slug":"蓝牙","permalink":"http://baidu.com/tags/蓝牙/"},{"name":"GameKit","slug":"GameKit","permalink":"http://baidu.com/tags/GameKit/"}]},{"title":"git","date":"2016-05-09T02:33:04.000Z","path":"2016/05/09/git/","text":"源代码管理工具-GIT一. git 概述1. git 简介? 什么是git? git是一款开源的分布式版本控制工具在世界上所有的分布式版本控制工具中，git是最快、最简单、最流行的 git的起源? 作者是Linux之父：Linus Benedict Torvalds当初开发git仅仅是为了辅助Linux内核的开发（管理源代码） git的现状? 在国外已经非常普及，国内并未普及（在慢慢普及）越来越多的开源项目已经转移到git 2. 常见的源代码管理工具有哪些? CVS 开启版本控制之门 1990年诞生，“远古时代”的主流源代码管理工具 SVN 全称是Subversion，集中式版本控制之王者 是CVS的接班人，速度比CVS快，功能比CVS多且强大 在国内软件企业中使用最为普遍（70%-90%） ClearCase 收费的集中式版本控制工具，安装比Windows还大，运行比蜗牛还慢 能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗或者人傻钱多 VSS 微软的集中式版本控制工具，集成在Visual Studio中 3. 集中式版本控制所有的代码都集中在一块, 统一进行管理 4. 分布式版本控制在每个客户端都有一份完整的代码仓库, 可以在每个客户端自行管理 5. git 和 svn的简单对比 速度 在很多情况下，git的速度远远比SVN快 结构 SVN是集中式管理，git是分布式管理 其他 SVN使用分支比较笨拙，git可以轻松拥有无限个分支 SVN必须联网才能正常工作，git支持本地版本控制工作 旧版本的SVN会在每一个目录置放一个.svn，git只会在根目录拥有一个.git 6. SVN工作流程和GIT工作流程对比12345678$ svn checkout —— git clone svn 只下载代码， git 会连同代码仓库一起下载下来$ svn commit —— git commit svn 是提交到服务器，git 中是提交到本地仓库，需要使用push才能提交到服务器$ svn update —— git pull 都是从服务器下载最新被修改的代码 分布式和集中式最大的区别在于：在分布式下，本地有个代码仓库,开发者可以在本地提交; 而集中式版本控制, 只有在服务器才有一个代码仓库, 只能在服务器进行统一管理 7. git工作原理 概念理解 工作区 与.git文件夹同级的其他文件夹或者子文件夹 版本控制库 暂缓区 分支(Git不像SVN那样有主干和分支的概念. 仅仅存在分支,其中master分支为默认被创建的分支,类似于SVN中的主干) 切换分支:通过控制HEAD指针指向不同的分支,就可以切换 操作原则: 所有新添加/删除/修改的文件 必须先添加到暂缓区,然后才能提交到HEAD指向的当前分支中 8. git使用环境 单人开发只需要一个本地库 原因:不需要与他人共享代码,只负责管理自己代码即可;例如提交代码,删除代码,版本控制等等 多人开发时需要一个共享版本库 共享版本库的形式: 本地共享库:文件夹/U盘/硬盘 远程共享库:自己搭建git服务器/ 托管到第三方平台(例如github, oschina) 使用环境 无论是单人开发还是多人开发,客户端都可以使用命令行或者图形界面使用git SourceTree 下载地址：http://www.sourcetreeapp.com/download/ GitHub 下载地址：https://mac.github.com不过它是专门为GitHub网站而设计的 Xcode 虽然集成较好,但是只能做一些常用的简单操作,复杂操作还要使用命令行","tags":[{"name":"iOS","slug":"iOS","permalink":"http://baidu.com/tags/iOS/"},{"name":"git","slug":"git","permalink":"http://baidu.com/tags/git/"}]},{"title":"Hexo搭建个人博客","date":"2016-05-06T07:01:40.000Z","path":"2016/05/06/creatHexo/","text":"Hexo搭建个人博客 Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds. 大致解释是:Hexo是一个快速，简单和强大的博客框架。你写的Markdown（或其他语言）的帖子Hexo在几秒钟内就能生成静态文件; 环境配置安装Hexo非常容易。但是，你需要先安装几个其他的东西： Node.js作用：用来生成静态页面的 到Node.js官网下载相应平台的最新版本，一路安装即可。官网入口 Github账号作用：用来做博客的远程创库、域名、静态资源服务器。怎么申请github的账号和ssh key等,请大家自行搜索,网络上资源还是很丰富的。 关联Github添加ssh key到Github检查SSH keys是否存在Github执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤1.3将SSH key添加到Github中，否则进入下一步生成SSH key。 1$ ls -al ~/.ssh 生成新的ssh key执行如下命令生成public/private rsa key pair，注意将`your_email@example.com`换成你自己注册Github的邮箱地址。 1$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。 将ssh key添加到Github中Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。 进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key: Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。 正式安装Hexonodejs和git都安装好后，可执行如下命令安装hexo： 1$ sudo npm install -g hexo 初始化创建一个文件夹，如：Blog，进入到Blog里分别执行init命令和安装依赖命令： 12$ hexo init blog$ npm install 生成静态页面继续再Blog目录下执行如下命令，生成静态页面: 1$ hexo generate 或 hexo g 安装hexo-server插件1$ sudo npm install hexo-server 本地启动启动本地服务，进行文章预览调试，命令： 1$ hexo server 或 hexo s 浏览器输入localhost:4000进行预览博客网站,是不是很简陋呢,但是好歹有一个自己的家园了,也是很兴奋呢。但是现在都是在本地进行的,需要和github进行关联。 配置Github建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法 然后建立关联,例如我的是:luojinghui.github.io,此时,你的目录应该是这样子: Blog ｜ ｜－－ _config.yml ｜－－ node_modules ｜－－ public ｜－－ source ｜－－ db.json ｜－－ package.json ｜－－ scaffolds ｜－－ themes 现在我们需要修改_config.yml文件，用编辑器打开,翻到最后,改成这个样子(注意冒号后面的空格): 1234deploy: type: git repository: https://github.com/liyilian/liyilian.github.io branch: master 执行如下命才能使用git部署(只需要执行一次): 1$ npm install hexo-deployer-git --save 执行这个命令进行部署: 1$ hexo deploy 然后在浏览器中输入 http://liyilian.github.io 就行了，我的 github 的账户叫 liyilian ,把这个改成你 github 的账户名就行了 备注每次部署的步骤，可按以下三步来进行: 123$ hexo clean$ hexo generate$ hexo deploy 简写: 12$ hexo clean$ hexo g -d 一些常用命令： 1234567$ hexo new &quot;postName&quot; #新建文章$ hexo new page &quot;pageName&quot; #新建页面$ hexo generate #生成静态页面至public目录$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭$ server）$ hexo deploy #将.deploy目录部署到GitHub$ hexo help #查看帮助$ hexo version #查看Hexo的版本 主题这里面有很多主题,可以参考: Hexo官网主题页 图片路径1.文章在 source/_posts下新建以.md为结尾的文件，编辑器可以用Webstrom、Sublime，支持 markdown 语法2.修改头像可以直接在主题里的 _config.yml 文件里面修改，友情链接，之类的都在这里3.创建文章的文件开头格式,可以用我现用的格式去写: 12345678910---title: 填写标题tags: - tag1- tag2date: 2016/6/06 12:20:25reward: 是否支持打赏,填写true或者falsekeywords: 关键词1 关键词2...description: 填写描述--- 4.如果想引用本地图片路径,以根路径作为起始点,就可以了。例如: /img/logo.png开始打理你的博客吧，有什么问题下面留言,我会回复的。 Q&amp;A 问：如何让文章想只显示一部分和一个 阅读全文 的按钮？答：在文章中加一个 &lt;!--more--&gt; ， &lt;!--more--&gt; 后面的内容就不会显示出来了。 问：如何添加多说评论?答：在主题里的 _config.yml中找到duoshuo:,冒号后面填写你在多说申请用的域名,例如,我申请的是liyilian.duoshuo.com,那么,在这里就填写liyilian,就好了 转载请注明原地址，liyilian的博客：https://liyilian.github.io/ 谢谢！","tags":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://baidu.com/tags/搭建博客/"},{"name":"主题配置","slug":"主题配置","permalink":"http://baidu.com/tags/主题配置/"}]},{"title":"runtime简介","date":"2016-05-05T03:48:52.000Z","path":"2016/05/05/runtime/","text":"一、runtime简介 RunTime简称运行时。OC就是运行时机制，也就是在运行时候的一些机制，其中最主要的是消息机制。 对于C语言，函数的调用在编译的时候会决定调用哪个函数。 对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。 事实证明： 在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。 在编译阶段，C语言调用未实现的函数就会报错。 二、runtime作用1.发送消息 方法调用的本质，就是让对象发送消息。 objc_msgSend,只有对象才能发送消息，因此以objc开头. 使用消息机制前提，必须导入#import &lt;objc/message.h&gt; 消息机制简单使用 123456789101112131415161718// 创建person对象Person *p = [[Person alloc] init];// 调用对象方法 [p eat];// 本质：让对象发送消息 objc_msgSend(p, @selector(eat));// 调用类方法的方式：两种// 第一种通过类名调用[Person eat];// 第二种通过类对象调用[[Person class] eat];// 用类名调用类方法，底层会自动把类名转换成类对象调用// 本质：让类对象发送消息 objc_msgSend([Person class], @selector(eat)); 消息机制原理:对象根据方法编号SEL去映射表查找对应的方法实现 2.交换方法 开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。 方式一:继承系统的类，重写方法. 方式二:使用runtime,交换方法. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。 // 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name; // 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。 UIImage *image = [UIImage imageNamed:@\"123\"];&#125;@end@implementation UIImage (Image)// 加载分类到内存的时候调用+ (void)load&#123; // 交换方法 // 获取imageWithName方法地址 Method imageWithName = class_getClassMethod(self, @selector(imageWithName:)); // 获取imageWithName方法地址 Method imageName = class_getClassMethod(self, @selector(imageNamed:)); // 交换方法地址，相当于交换实现方式 method_exchangeImplementations(imageWithName, imageName);&#125;// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.// 既能加载图片又能打印+ (instancetype)imageWithName:(NSString *)name&#123; // 这里调用imageWithName，相当于调用imageName UIImage *image = [self imageWithName:name]; if (image == nil) &#123; NSLog(@\"加载空的图片\"); &#125; return image;&#125;@end 3.动态添加方法 开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。 经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。 简单使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. Person *p = [[Person alloc] init]; // 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。 // 动态添加方法就不会报错 [p performSelector:@selector(eat)];&#125;@end@implementation Person// void(*)()// 默认方法都有两个隐式参数，void eat(id self,SEL sel)&#123; NSLog(@\"%@ %@\",self,NSStringFromSelector(sel));&#125;// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if (sel == @selector(eat)) &#123; // 动态添加eat方法 // 第一个参数：给哪个类添加方法 // 第二个参数：添加方法的方法编号 // 第三个参数：添加方法的函数实现（函数地址） // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd class_addMethod(self, @selector(eat), eat, \"v@:\"); &#125; return [super resolveInstanceMethod:sel];&#125;@end 4.给分类添加属性 原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。 12345678910111213141516171819202122232425262728293031323334353637383940@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 给系统NSObject类动态添加属性name NSObject *objc = [[NSObject alloc] init]; objc.name = @\"小码哥\"; NSLog(@\"%@\",objc.name);&#125;@end// 定义关联的keystatic const char *key = \"name\";@implementation NSObject (Property)- (NSString *)name&#123; // 根据关联的key，获取关联的值。 return objc_getAssociatedObject(self, key);&#125;- (void)setName:(NSString *)name&#123; // 第一个参数：给哪个对象添加关联 // 第二个参数：关联的key，通过这个key获取 // 第三个参数：关联的value // 第四个参数:关联的策略 objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 5.字典转模型 设计模型：字典转模型的第一步 模型属性，通常需要跟字典中的key一一对应 问题：一个一个的生成模型属性，很慢？ 需求：能不能自动根据一个字典，生成对应的属性。 解决：提供一个分类，专门根据字典生成对应的属性字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243@implementation NSObject (Log)// 自动打印属性字符串+ (void)resolveDict:(NSDictionary *)dict&#123; // 拼接属性字符串代码 NSMutableString *strM = [NSMutableString string]; // 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码 [dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; // 类型经常变，抽出来 NSString *type; if ([obj isKindOfClass:NSClassFromString(@\"__NSCFString\")]) &#123; type = @\"NSString\"; &#125;else if ([obj isKindOfClass:NSClassFromString(@\"__NSCFArray\")])&#123; type = @\"NSArray\"; &#125;else if ([obj isKindOfClass:NSClassFromString(@\"__NSCFNumber\")])&#123; type = @\"int\"; &#125;else if ([obj isKindOfClass:NSClassFromString(@\"__NSCFDictionary\")])&#123; type = @\"NSDictionary\"; &#125; // 属性字符串 NSString *str; if ([type containsString:@\"NS\"]) &#123; str = [NSString stringWithFormat:@\"@property (nonatomic, strong) %@ *%@;\",type,key]; &#125;else&#123; str = [NSString stringWithFormat:@\"@property (nonatomic, assign) %@ %@;\",type,key]; &#125; // 每生成属性字符串，就自动换行。 [strM appendFormat:@\"\\n%@\\n\",str]; &#125;]; // 把拼接好的字符串打印出来，就好了。 NSLog(@\"%@\",strM); &#125; @end 字典转模型的方式一：KVC 12345678910111213 @implementation Status + (instancetype)statusWithDict:(NSDictionary *)dict &#123; Status *status = [[self alloc] init]; [status setValuesForKeysWithDictionary:dict]; return status; &#125; @end KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。 如果不一致，就会调用[ setValue:forUndefinedKey:] 报key找不到的错。 分析:模型中的属性和字典的key不一一对应，系统就会调用setValue:forUndefinedKey:报错。 解决:重写对象的setValue:forUndefinedKey:,把系统的方法覆盖， 就能继续使用KVC，字典转模型了。 1234- (void)setValue:(id)value forUndefinedKey:(NSString *)key&#123;&#125; 字典转模型的方式二：Runtime 思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。 步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 解析Plist文件 NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;status.plist&quot; ofType:nil]; NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath]; // 获取字典数组 NSArray *dictArr = statusDict[@&quot;statuses&quot;]; // 自动生成模型的属性字符串// [NSObject resolveDict:dictArr[0][@&quot;user&quot;]]; _statuses = [NSMutableArray array]; // 遍历字典数组 for (NSDictionary *dict in dictArr) &#123; Status *status = [Status modelWithDict:dict]; [_statuses addObject:status]; &#125; // 测试数据 NSLog(@&quot;%@ %@&quot;,_statuses,[_statuses[0] user]);&#125;@end@implementation NSObject (Model)+ (instancetype)modelWithDict:(NSDictionary *)dict&#123; // 思路：遍历模型中所有属性-》使用运行时 // 0.创建对应的对象 id objc = [[self alloc] init]; // 1.利用runtime给对象中的成员属性赋值 // class_copyIvarList:获取类中的所有成员属性 // Ivar：成员属性的意思 // 第一个参数：表示获取哪个类中的成员属性 // 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值 // 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。 /* 类似下面这种写法 Ivar ivar; Ivar ivar1; Ivar ivar2; // 定义一个ivar的数组a Ivar a[] = &#123;ivar,ivar1,ivar2&#125;; // 用一个Ivar *指针指向数组第一个元素 Ivar *ivarList = a; // 根据指针访问数组第一个元素 ivarList[0]; */ unsigned int count; // 获取类中的所有成员属性 Ivar *ivarList = class_copyIvarList(self, &amp;count); for (int i = 0; i &lt; count; i++) &#123; // 根据角标，从数组取出对应的成员属性 Ivar ivar = ivarList[i]; // 获取成员属性名 NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 处理成员属性名-&gt;字典中的key // 从第一个角标开始截取 NSString *key = [name substringFromIndex:1]; // 根据成员属性名去字典中查找对应的value id value = dict[key]; // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型 // 判断下value是否是字典 if ([value isKindOfClass:[NSDictionary class]]) &#123; // 字典转模型 // 获取模型的类对象，调用modelWithDict // 模型的类名已知，就是成员属性的类型 // 获取成员属性类型 NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; // 生成的是这种@&quot;@\\&quot;User\\&quot;&quot; 类型 -》 @&quot;User&quot; 在OC字符串中 \\&quot; -&gt; &quot;，\\是转义的意思，不占用字符 // 裁剪类型字符串 NSRange range = [type rangeOfString:@&quot;\\&quot;&quot;]; type = [type substringFromIndex:range.location + range.length]; range = [type rangeOfString:@&quot;\\&quot;&quot;]; // 裁剪到哪个角标，不包括当前角标 type = [type substringToIndex:range.location]; // 根据字符串类名生成类对象 Class modelClass = NSClassFromString(type); if (modelClass) &#123; // 有对应的模型才需要转 // 把字典转模型 value = [modelClass modelWithDict:value]; &#125; &#125; // 三级转换：NSArray中也是字典，把数组中的字典转换成模型. // 判断值是否是数组 if ([value isKindOfClass:[NSArray class]]) &#123; // 判断对应类有没有实现字典数组转模型数组的协议 if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123; // 转换成id类型，就能调用任何对象的方法 id idSelf = self; // 获取数组中字典对应的模型 NSString *type = [idSelf arrayContainModelClass][key]; // 生成模型 Class classModel = NSClassFromString(type); NSMutableArray *arrM = [NSMutableArray array]; // 遍历字典数组，生成模型数组 for (NSDictionary *dict in value) &#123; // 字典转模型 id model = [classModel modelWithDict:dict]; [arrM addObject:model]; &#125; // 把模型数组赋值给value value = arrM; &#125; &#125; if (value) &#123; // 有值，才需要给模型的属性赋值 // 利用KVC给模型中的属性赋值 [objc setValue:value forKey:key]; &#125; &#125; return objc; &#125; @end","tags":[{"name":"iOS","slug":"iOS","permalink":"http://baidu.com/tags/iOS/"},{"name":"runtime","slug":"runtime","permalink":"http://baidu.com/tags/runtime/"}]}]