<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[cocoaPods的使用]]></title>
    <url>%2F2016%2F05%2F19%2FcocoaPods%2F</url>
    <content type="text"><![CDATA[一、什么是CocoaPods每种语言发展到一个阶段，就会出现相应的依赖管理工具，例如 Java 语言的 Maven，nodejs 的 npm。随着 iOS 开发者的增多，业界也出现了为 iOS 程序提供依赖管理的工具，它的名字叫做：CocoaPods。CocoaPods项目的源码 在 Github 上管理。该项目开始于 2011 年 8 月 12 日，经过多年发展，现在已经成为 iOS 开发事实上的依赖管理标准工具。开发 iOS 项目不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。 二、为什么要使用CocoaPods在使用CocoaPods之前，开发项目需要用到第三方开源库的时候，我们需要 1.把开源库的源代码复制到项目中 2.添加一些依赖框架和动态库 3.设置-ObjC，-fno-objc-arc等参数 4.管理他们的更新 在使用CocoaPods后，我们只需要把用到的开源库放到一个名为Podfile的文件中，然后执行pod install就可以了，Cocoapods就会自动将这些第三方开源库的源码下载下来，并且为我们的工程设置好响应的系统依赖和编译参数。 三、CocoaPods的原理CocoaPods的原理是将所有的依赖库都放到另一个名为Pods的项目中，然后让主项目依赖Pods项目，这样，源码管理工作都从主项目移到了Pods项目中。Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖这个.a文件即可。 四、CocoaPods的安装1. 设置ruby的软件源1234567$ gem sources -l #(查看当前ruby的源)$ gem sources --remove https://rubygems.org/ #(移除当前ruby的源)$ gem sources -a https://gems.ruby-china.org/(原来的淘宝镜像 https://ruby.taobao.org/已经不能用了)$ gem sources -l #(再次查看当前ruby的源) 如果Terminal输出： CURRENT SOURCES https://gems.ruby-china.org/ 可以用gem sources -l 来检查使用替换镜像位置成功，结果应该只有 https://gems.ruby-china.org/ 才对。 就证明ruby的软件源已经设置OK了。 2. 设置gem为最新版本1$ sudo gem update --system 升级成功后会提示: Latest version currently installed. Aborting. 3. 执行安装CocoaPods命令 $ sudo gem install cocoapods // Mac OS X 10.11前 输入这一条 $ sudo gem install -n /usr/local/bin cocoapods //Mac OS X 10.11后 输入这一条 成功后 $ pod setup 这条命令是将Github上的开源库都托管都安装Podspec索引安装到到本 地, 这一步, 很慢….. 很慢………. 很慢…………… 大约要下载200M的文件,偏偏下载速度出奇的慢,本人保持在30K/S,大约2个小时,关键是没有任何进度条显示,就这样傻乎乎的卡死在这里 五、Cocoapods的使用1. 引入第三方库到项目中 创建一个工程，并创建podfile配置文件 先用cd进入到工程中去输入指令vim podfile创建podfile文件，然后按i进入到编辑模式配置文件固定语句如下： 1234platform :ios, &apos;8.0&apos;target &apos;TargetName&apos; dopod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos;end 然后按esc，接着按” : “ 然后输入wq 按回车键 返回终端界面， 输入终端命令 1$ pod install 意思是初始化，所以每次添加新的库的时候，之前的指令都不能删除，它只会添加指令中有的库。 如果发现安装cocoapods之后，初始化pod时在receive object是正常情况 需要耐心等待。 2. 更新CocoaPods中的第三方们。 第三方库们都有人在维护升级，我们需要隔断时间就要更新下我们工程中第三方库的版本。只需要终端输入命令 1$ pod update 就可以了。 如果遇到podinstall或者pod update慢的问题，原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下： 12$ pod install --verbose --no-repo-update$ pod update --verbose --no-repo-update 3. 删除CocoaPods中的某些第三方们。当我们需要去掉某个第三方库时，只需要在Podfile删除该引入该库的语句，然后执行 1$ pod update或者 $ pod install 就可以了。 4. 将CocoaPods从项目中删除如果你在以后的使用过程中不想用CocoaPods了怎么办？很简单，把多出来的东西们都删掉就可以了，不过为了项目正常运行，你需要手动导入已经使用的第三方们哦。 5. 升级CocoaPods升级CocoaPods版本的命令和安装CocoaPods的命令一样，都是 1$ sudo gem install cocoapods。 如果老版本升级cocoapods的时候提示Operation not permitted - /usr/bin/xcodeproj，改用命令 1$ sudo gem install -n /usr/local/bin cocoapods --pre 就可以了。 6. 卸载CocoaPods卸载CocoaPods的命令是： 1$ sudo gem uninstall cocoapods 六、 文章的最后附上一些常用指令1. pod安装12345678# 添加源$ sudo gem sources -a https://ruby.taobao.org/# 删除源$ sudo gem sources -r https://rubygems.org/# 安装$ sudo gem install cocoapods# 设置$ pod setup 2. gem常用命令123456789101112# 查看版本$ gem --version# 清除过期的gem$ sudo gem cleanup# 安装包$ sudo gem install cocoapods# 删除包$ gem uninstall cocoapods# 更新包$ sudo gem update# 列出本地安装的包$ gem list 3. pod命令123456789101112# 第一次使用安装框架 //只用安装一次,之后使用 添加删除都用 pod update --no-repo-update $ pod install# 安装框架，不更新本地索引，速度快$ pod install --no-repo-update # 今后升级、添加、删除框架，或者框架不好用$ pod update# 更新框架，不更新本地索引，速度快$ pod update --no-repo-update # 搜索框架$ pod search XXX# 帮助$ pod --help]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>cocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Native.js]]></title>
    <url>%2F2016%2F05%2F17%2FNative-js%2F</url>
    <content type="text"><![CDATA[Native.js技术，简称NJS，是一种将手机操作系统的原生对象转义，映射为JS对象，在JS里编写原生代码的技术。如果说Node.js把js扩展到服务器世界，那么Native.js则把js扩展到手机App的原生世界。HTML/JS/Css全部语法只有7万多，而原生语法有几十万，Native.js大幅提升了HTML5的能力。NJS突破了浏览器的功能限制，也不再需要像Hybrid那样由原生语言开发插件才能补足浏览器欠缺的功能。NJS编写的代码，最终需要在HBuilder里打包发行为App安装包，或者在支持Native.js技术的浏览器里运行。目前Native.js技术不能在普通手机浏览器里直接运行。 NJS大幅扩展了HTML5的能力范围，原本只有原生或Hybrid App的原生插件才能实现的功能如今可以使用JS实现。 NJS大幅提升了App开发效率，将iOS、Android、Web的3个工程师组队才能完成的App，变为1个web工程师就搞定。 NJS不再需要配置原生开发和编译环境，调试、打包均在HBuilder里进行。没有mac和xcode一样可以开发iOS应用。 如果不熟悉原生API也没关系，我们汇总了很多NJS的代码示例，复制粘贴就可以用。http://ask.dcloud.net.cn/article/114 再次强调，Native.js不是一个js库，不需要下载引入到页面的script中，也不像nodejs那样有单独的运行环境，Native.js的运行环境是集成在5+runtime里的，使用HBuilder打包的app或流应用都可以直接使用Native.js。]]></content>
      <categories>
        <category>Native</category>
      </categories>
      <tags>
        <tag>Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react native的优缺点]]></title>
    <url>%2F2016%2F05%2F17%2FreactNative%2F</url>
    <content type="text"><![CDATA[React Native 优缺点分析经过一长篇的讨论，其实 React Native 的优缺点已经不难分析了，这里简单总结一下： 优点 复用了 React 的思想，有利于前端开发者涉足移动端。 能够利用 JavaScript 动态更新的特性，快速迭代。 相比于原生平台，开发速度更快，相比于 Hybrid 框架，性能更好 缺点 做不到 Write once, Run everywhere，也就是说开发者依然需要为 iOS 和 Android 平台提供两套不同的代码，比如参考官方文档可以发现不少组件和API都区分了 Android 和 iOS 版本。即使是共用组件，也会有平台独享的函数。 不能做到完全屏蔽 iOS 端或 Android 的细节，前端开发者必须对原生平台有所了解。加重了学习成本。对于移动端开发者来说，完全不具备用 React Native 开发的能力。 由于 Objective-C 与 JavaScript 之间切换存在固定的时间开销，所以性能必定不及原生。比如目前的官方版本无法做到 UItableview(ListView) 的视图重用，因为滑动过程中，视图重用需要在异步线程中执行，速度太慢。这也就导致随着 Cell 数量的增加，占用的内存也线性增加。 综上，我对 React Native 的定位是： 利用脚本语言进行原生平台开发的一次成功尝试，降低了前端开发者入门移动端的门槛，一定业务场景下具有独特的优势，几乎不可能取代原生平台开发。]]></content>
      <categories>
        <category>react native</category>
      </categories>
      <tags>
        <tag>react native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocoaPods导入环信Hyphenate时出的问题]]></title>
    <url>%2F2016%2F05%2F12%2Feasemob%2F</url>
    <content type="text"><![CDATA[出现问题 1234567Apin-iOS:Apin2017 aipinji$ pod installAnalyzing dependencies[!] Unable to satisfy the following requirements:- `Hyphenate (~&gt; 3.3.1)` required by `Podfile`Specs satisfying the `Hyphenate (~&gt; 3.3.1)` dependency were found, but they required a higher minimum deployment target. 解决方法 12345678910111213141516171819202122232425platform :ios,&apos;8.0&apos;target &quot;Apin&quot; dopod &apos;pop&apos;, &apos;~&gt; 1.0&apos;pod &apos;Masonry&apos;pod &apos;IQKeyboardManager&apos;pod &apos;YYModel&apos;pod &apos;Bugly&apos;, &apos;~&gt; 2.4.2&apos;pod &apos;UMengAnalytics-NO-IDFA&apos;, &apos;~&gt; 4.1.9&apos;pod &apos;MBProgressHUD&apos;, &apos;~&gt; 0.9&apos;pod &apos;PKRevealController&apos;pod &apos;AMap3DMap&apos;pod &apos;AMapSearch&apos;pod &apos;TZImagePickerController&apos;pod &apos;MJRefresh&apos;pod &apos;SDWebImage&apos;, &apos;~&gt;3.8&apos;pod &apos;AFNetworking&apos;, &apos;~&gt; 3.1.0&apos;pod &apos;WebViewJavascriptBridge&apos;, &apos;~&gt; 5.0&apos;pod &apos;UMengUShare/UI&apos;pod &apos;UMengUShare/Social/Sina&apos;pod &apos;UMengUShare/Social/WeChat&apos;pod &apos;UMengUShare/Social/QQ&apos;pod &apos;SDCycleScrollView&apos;,&apos;~&gt; 1.64&apos;pod &apos;Hyphenate&apos;, &apos;~&gt; 3.3.1&apos;pod &apos;EaseUI&apos;, :git =&gt; &apos;https://github.com/easemob/easeui-ios-hyphenate-cocoapods.git&apos;end 出现问题 12345678Apin-iOS:Apin2017 aipinji$ pod installAnalyzing dependenciesPre-downloading: `EaseUI` from `https://github.com/easemob/easeui-ios-hyphenate-cocoapods.git`[!] Unable to satisfy the following requirements:- `MBProgressHUD` required by `Podfile`- `MBProgressHUD (= 1.0.0)` required by `Podfile.lock`- `MBProgressHUD (~&gt; 0.9)` required by `MWPhotoBrowser (2.1.1)` 解决方法 1pod &apos;MBProgressHUD&apos;, &apos;~&gt; 0.9&apos;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>cocoaPods</tag>
        <tag>Hyphenate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreBlueTooth]]></title>
    <url>%2F2016%2F05%2F10%2FCoreBlueTooth%2F</url>
    <content type="text"><![CDATA[iOS之蓝牙简介和使用(三)：CoreBlueToothCoreBlueTooth简介： 可用于第三方蓝牙设备交互，设备必须支持蓝牙4.0 iPhone的设备必须是4S或者更新 iPad设备必须是iPad mini或者更新 iOS的系统必须是iOS 6或者更新 蓝牙4.0以低功耗著称，所以一般被称为BLE（bluetooth low energy） 使用模拟器调试 Xcode 4.6 iOS 6.1 应用场景 运动手环 智能家居 拉卡拉蓝牙刷卡器 核心概念 CBCentralManager：中心设备（用来连接到外部设备的管家） CBPeripheralManager：外部设备（第三方的蓝牙4.0设备）这里写图片描述 开发步骤 建立中心管家 12// 1. 创建中心管家,并且设置代理self.cmgr = [[CBCentralManager alloc]initWithDelegate:self queue:nil]; 扫描外设（discover） 123456789101112// 2. 在代理方法中扫描外部设备 /** * scanForPeripheralsWithServices ：如果传入指定的数组，那么就只会扫描数组中对应ID的设备 * 如果传入nil，那么就是扫描所有可以发现的设备 * 扫描完外部设备就会通知CBCentralManager的代理 */ - (void)centralManagerDidUpdateState:(CBCentralManager *)central&#123; if ([central state] == CBCentralManagerStatePoweredOn) &#123; [self.cmgr scanForPeripheralsWithServices:nil options:nil]; &#125;&#125; 123456789101112/** * 发现外部设备，每发现一个就会调用这个方法 * 所以可以使用一个数组来存储每次扫描完成的数组 */- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *,id&gt; *)advertisementData RSSI:(NSNumber *)RSSI&#123; // 有可能会导致重复添加扫描到的外设 // 所以需要先判断数组中是否包含这个外设 if(![self.peripherals containsObject:peripheral])&#123; [self.peripherals addObject:peripheral]; &#125;&#125; 连接外设 1234567891011121314/** * 模拟开始连接方法 */- (void)start&#123; // 3. 连接外设 for (CBPeripheral *ppl in self.peripherals) &#123; // 扫描外设的服务 // 这个操作应该交给外设的代理方法来做 // 设置代理 ppl.delegate = self; [self.cmgr connectPeripheral:ppl options:nil]; &#125;&#125; 扫描外设中的服务和特征 服务和特征的关系 每个蓝牙4.0的设备都是通过服务和特征来展示自己的，一个设备必然包含一个或多个服务，每个服务下面又包含若干个特征。 12345678/** * 连接外设成功调用 */- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123; // 查找外设服务 [peripheral discoverServices:nil];&#125; 1234567891011121314/** * 发现服务就会调用代理方法 * * @param peripheral 外设 */- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error&#123; // 扫描到设备的所有服务 NSArray *services = peripheral.services; // 根据服务再次扫描每个服务对应的特征 for (CBService *ses in services) &#123; [peripheral discoverCharacteristics:nil forService:ses]; &#125;&#125; 与外设做数据交互 在指定的特征下做相应的操作 123456789101112131415/** * 发现服务对应的特征 */- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error&#123; // 服务对应的特征 NSArray *ctcs = service.characteristics; // 遍历所有的特征 for (CBCharacteristic *character in ctcs) &#123; // 根据特征的唯一标示过滤 if ([character.UUID.UUIDString isEqualToString:@&quot;XMG&quot;]) &#123; NSLog(@&quot;可以吃饭了&quot;); &#125; &#125;&#125; 断开连接 12345678910/** * 断开连接 */- (void)stop&#123; // 断开所有连接上的外设 for (CBPeripheral *per in self.peripherals) &#123; [self.cmgr cancelPeripheralConnection:per]; &#125;&#125; 原文地址：http://blog.csdn.net/wzc10101415/article/details/55101405]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
        <tag>CoreBlueTooth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之蓝牙简介和使用(二)：MutipeerConnectivity]]></title>
    <url>%2F2016%2F05%2F09%2FMutipeerConnectivity%2F</url>
    <content type="text"><![CDATA[iOS之蓝牙简介和使用(二)：MutipeerConnectivity蓝牙mutipeerConnectivity简介 iOS 7引入的一个全新框架 多点连接 替代GameKit框架 多用于文件的传输 iOS设备不联网也能跟附近的人聊天 123* FireChat* See You Around* 以上近场聊天App都是基于mutipeerConnectivity框架 搜索和传输的方式 1234* 双方WIFI和蓝牙都没有打开：无法实现* 双方都开启蓝牙：通过蓝牙发现和传输* 双方都开启WIFI：通过WIFI Direct发现和传输，速度接近AirDrop* 双方同时开启了WIFI和蓝牙：模拟AirDrop，通过低功耗蓝牙技术扫描发现握手，然后通过WIFI Direct传输 案例界面搭建连接设备 创建MCSession对象用于存放当前连接的会话 1234// 创建MCSession对象// initWithPeer：设备的ID// 用于存放当前的连接的会话self.mc_Session = [ [MCSession alloc]initWithPeer:[[MCPeerID alloc] initWithDisplayName:[UIDevice currentDevice].name]]; 开启广播对象，通知正在搜索的设备他们是可用的 12345678910111213141516171819202122/** * 只要开启了可被搜索的广播，那么连接蓝牙按钮就不可点 */- (IBAction)foundConnect:(id)sender &#123; UISwitch *switchBtn = (UISwitch *)sender; if (switchBtn.isOn) &#123; // 广播对象，告诉其它的设备他们是可用的 if (self.advertiserAssistant == nil) &#123; // 创建广播对象 // initWithServiceType： 广播类型的标示（因为广播可能比较多，所以最好每个广播绑定一个唯一标示） // session：当前会话 // discoveryInfo： 广播信息 self.advertiserAssistant = [[MCAdvertiserAssistant alloc] initWithServiceType:SERVICE_TYPE discoveryInfo:nil session:self.mc_Session]; &#125; // 开启广播 [self.advertiserAssistant start]; self.connectBT.enabled = NO; &#125;else&#123; self.connectBT.enabled = YES; &#125;&#125; 开始搜索蓝牙设备 12345678- (IBAction)connectBlueTooth &#123; // 创建搜索蓝牙设备控制器 MCBrowserViewController *mbVC = [[MCBrowserViewController alloc]initWithServiceType:SERVICE_TYPE session:self.mc_Session]; // 设置控制器代理 mbVC.delegate = self; // 跳转到搜索控制器 [self presentViewController:mbVC animated:YES completion:nil];&#125; 选择数据12345678910111213- (IBAction)selectImage &#123; // 1. 创建图片选择器 UIImagePickerController *imgPicker = [[UIImagePickerController alloc]init]; // 2. 判断图片选择器是否可用 if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeSavedPhotosAlbum]) &#123; // 选择器打开的类型 imgPicker.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum; // 设置代理 imgPicker.delegate = self; // 打开图片选择器 [self presentViewController:imgPicker animated:YES completion:nil]; &#125;&#125; 图片选择器代理中获取数据 123456789// 选择完毕调用- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info&#123;// NSLog(@&quot;info == %@&quot;,info); // 设置显示图片 self.showImage.image = info[UIImagePickerControllerOriginalImage]; // 隐藏图片显示器 [picker dismissViewControllerAnimated:YES completion:nil];&#125; 在搜索控制器的连接完成的代理方法中隐藏搜索控制器 12345678910/** * 连接完成 * * @param browserViewController 搜索控制器 */- (void)browserViewControllerDidFinish:(MCBrowserViewController *)browserViewController&#123; [browserViewController dismissViewControllerAnimated:YES completion:nil]; NSLog(@&quot;%s %d&quot;,__func__,__LINE__);&#125; 发送数据 实现搜索控制器的代理方法，获取连接上的设备ID 123456789101112131415161718#pragma mark - MCBrowserViewControllerDelegate/** * 连接成功 * * @param browserViewController 搜索控制器 * @param peerID 连接上的设备ID * @param info 连接的信息 * * @return YES ： 只发送连接上的用户 */- (BOOL)browserViewController:(MCBrowserViewController *)browserViewController shouldPresentNearbyPeer:(MCPeerID *)peerID withDiscoveryInfo:(nullable NSDictionary&lt;NSString *, NSString *&gt; *)info&#123; self.peerID = peerID; NSLog(@&quot;info == %@ peer = %@&quot;,info, peerID); return YES;&#125; 将图片发送给连接上的ID 1234567891011121314- (IBAction)sendImage &#123; // 获取图片 UIImage *image = self.showImage.image; // 将图片转换成NSData类型 NSData *data = UIImagePNGRepresentation(image); /** * 发送数据 * toPeers ： 发给的设备ID的数组 * withMode： 发送模式，是否是安全模式 */ if (self.peerID != nil) &#123; [self.mc_Session sendData:data toPeers:@[self.peerID] withMode:MCSessionSendDataUnreliable error:nil]; &#125;&#125; 接收数据 实现MCSession的代理方法接受数据 12345- (void)session:(MCSession *)session didReceiveData:(NSData *)data fromPeer:(MCPeerID *)peerID&#123; NSLog(@&quot;%s %d&quot;,__func__,__LINE__); NSLog(@&quot;data = %@ , peer = %@&quot;,data,peerID);&#125; 显示数据 在MCSeesion代理方法中设置获取过来的数据 12345678910111213// 接收的数据- (void)session:(MCSession *)session didReceiveData:(NSData *)data fromPeer:(MCPeerID *)peerID&#123; NSLog(@&quot;%s %d&quot;,__func__,__LINE__);// NSLog(@&quot;data = %@ , peer = %@&quot;,data,peerID); UIImage *image = [[UIImage alloc]initWithData:data]; if(image != nil)&#123; // 设置数据 dispatch_async(dispatch_get_main_queue(), ^&#123; self.showImage.image = image; &#125;); &#125;&#125; 原文地址：http://blog.csdn.net/wzc10101415/article/details/55101346]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
        <tag>MutipeerConnectivity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之蓝牙简介和使用(一)：GameKit]]></title>
    <url>%2F2016%2F05%2F09%2FGameKit%2F</url>
    <content type="text"><![CDATA[iOS之蓝牙简介和使用(一)：GameKit蓝牙GameKit简介： 实现蓝牙设备之间的通讯 只能使用在iOS设备之间同一个应用内连接 从iOS7开始过期了 但是GameKit是最基本的蓝牙通讯框架 通过蓝牙可以实现文件的共享（仅限设备沙盒中的文件） 此框架一般用于游戏开发（比如五子棋对战） 开始案例简介： 使用蓝牙将两个iOS设备连接起来 搜索对方的设备 实现将手机中的图片发送给对方 界面的搭建：蓝牙互连： 搜索蓝牙设备 1234// 初始化链接蓝牙控制器 GKPeerPickerController *peerCtr = [[GKPeerPickerController alloc]init]; // 显示匹配到的蓝牙设备 [peerCtr show]; GKPeerPickerController最重要的两个代理 12345678910111213141516171819/** * 链接成功 * * @param picker 蓝牙控制器 * @param peerID 连接蓝牙的设备id * @param session 连接蓝牙的会话（通讯）用来传数据 */- (void)peerPickerController:(GKPeerPickerController *)picker didConnectPeer:(NSString *)peerID toSession:(GKSession *)session&#123; NSLog(@&quot;%s %d&quot;,__func__,__LINE__); // 隐藏蓝牙控制器 [picker dismiss];&#125;// 退出连接- (void)peerPickerControllerDidCancel: (GKPeerPickerController *)picker&#123; NSLog(@&quot;%s %d&quot;,__func__,__LINE__);&#125; 选择图片： 选择图片方法 1234567891011121314 // 选择图片- (IBAction)chooseImage &#123; // 1.初始化图片选择控制器 UIImagePickerController *imgPicker = [[UIImagePickerController alloc]init]; // 2.判断图库是否可用 if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeSavedPhotosAlbum]) &#123; // 3.设置图库打开的类型 imgPicker.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum; // 4. 设置代理 imgPicker.delegate = self; // 5. 打开图库 [self presentViewController:imgPicker animated:YES completion:nil]; &#125;&#125; 选择图片控制器的代理方法 1234567891011121314 /** * 图片选择完成调用 * * @param picker 图片选择控制器 * @param info 选择的信息 */- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info&#123; NSLog(@&quot;info == %@&quot;,info); // 设置选择的图片为当前的显示图片 self.showImageView.image = info[UIImagePickerControllerOriginalImage]; // 隐藏当前选择图片控制器 [picker dismissViewControllerAnimated:YES completion:nil];&#125; 图片相互发送： 需要在连接成功代理方法中存储当前的会话 12// 保存当前回话 self.m_Session = session; 发送图片方法 123456789101112131415161718 // 发送图片- (IBAction)sendImage &#123; // 拿到需要发送出去的图片 UIImage *image = self.showImageView.image; // 将图片转换成NSData类型 NSData *imgData = UIImagePNGRepresentation(image); /** * 发送数据给所有匹配上的用户 * * @param GKSendDataMode 数据发送的模式：（安全/不安全模式） * GKSendDataUnreliable : 不安全模式：就像发10个传单，传单直接往人群中砸过去，能不能收到不管 * GKSendDataReliable：安全模式：就像发10个传单，每一个传单都得发到路人的手上，才再发下一个传单 * @return */ [self.m_Session sendDataToAllPeers:imgData withDataMode:GKSendDataUnreliable error:nil];&#125; 设置图片： GameKit提供的接受数据是方法的回调 需要监听接收传递过来的数据 在连接成功代理方法中设置监听 12345/** 监听传递过来的数据 * setDataReceiveHandler: 由哪个对象来监听数据的接受 * withContext ： 监听需要传递的参数 */ [session setDataReceiveHandler:self withContext:nil]; 实现监听方法 只设置由谁监听传递过来的数据还是不足的，因为我们还是不能拿到传递过来的数据，进入监听方法的头文件可以看到 1// SEL = -receiveData:fromPeer:inSession:context: 所以我们必须实现这个方法才能拿到接收到的数据，这个回调方法方法在Xcode 7之前的版本的解释如图： 123456789101112131415 /** * 实现接收数据的回调方法 * * @param data 接收到的数据 * @param peer 传递数据的设备ID * @param session 当前回话 * @param context 注册监听传递过来的数据 */- (void) receiveData:(NSData *)data fromPeer:(NSString *)peer inSession: (GKSession *)session context:(void *)context&#123; // 因为传递过来的是图片，所以我们直接使用UIImage来接受 UIImage *image = [UIImage imageWithData:data]; // 设置图片 self.showImageView.image = image;&#125; 原文地址：http://blog.csdn.net/wzc10101415/article/details/55101321]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
        <tag>GameKit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2016%2F05%2F09%2Fgit%2F</url>
    <content type="text"><![CDATA[源代码管理工具-GIT一. git 概述1. git 简介? 什么是git? git是一款开源的分布式版本控制工具在世界上所有的分布式版本控制工具中，git是最快、最简单、最流行的 git的起源? 作者是Linux之父：Linus Benedict Torvalds当初开发git仅仅是为了辅助Linux内核的开发（管理源代码） git的现状? 在国外已经非常普及，国内并未普及（在慢慢普及）越来越多的开源项目已经转移到git 2. 常见的源代码管理工具有哪些? CVS 开启版本控制之门 1990年诞生，“远古时代”的主流源代码管理工具 SVN 全称是Subversion，集中式版本控制之王者 是CVS的接班人，速度比CVS快，功能比CVS多且强大 在国内软件企业中使用最为普遍（70%-90%） ClearCase 收费的集中式版本控制工具，安装比Windows还大，运行比蜗牛还慢 能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗或者人傻钱多 VSS 微软的集中式版本控制工具，集成在Visual Studio中 3. 集中式版本控制所有的代码都集中在一块, 统一进行管理 4. 分布式版本控制在每个客户端都有一份完整的代码仓库, 可以在每个客户端自行管理 5. git 和 svn的简单对比 速度 在很多情况下，git的速度远远比SVN快 结构 SVN是集中式管理，git是分布式管理 其他 SVN使用分支比较笨拙，git可以轻松拥有无限个分支 SVN必须联网才能正常工作，git支持本地版本控制工作 旧版本的SVN会在每一个目录置放一个.svn，git只会在根目录拥有一个.git 6. SVN工作流程和GIT工作流程对比12345678$ svn checkout —— git clone svn 只下载代码， git 会连同代码仓库一起下载下来$ svn commit —— git commit svn 是提交到服务器，git 中是提交到本地仓库，需要使用push才能提交到服务器$ svn update —— git pull 都是从服务器下载最新被修改的代码 分布式和集中式最大的区别在于：在分布式下，本地有个代码仓库,开发者可以在本地提交; 而集中式版本控制, 只有在服务器才有一个代码仓库, 只能在服务器进行统一管理 7. git工作原理 概念理解 工作区 与.git文件夹同级的其他文件夹或者子文件夹 版本控制库 暂缓区 分支(Git不像SVN那样有主干和分支的概念. 仅仅存在分支,其中master分支为默认被创建的分支,类似于SVN中的主干) 切换分支:通过控制HEAD指针指向不同的分支,就可以切换 操作原则: 所有新添加/删除/修改的文件 必须先添加到暂缓区,然后才能提交到HEAD指向的当前分支中 8. git使用环境 单人开发只需要一个本地库 原因:不需要与他人共享代码,只负责管理自己代码即可;例如提交代码,删除代码,版本控制等等 多人开发时需要一个共享版本库 共享版本库的形式: 本地共享库:文件夹/U盘/硬盘 远程共享库:自己搭建git服务器/ 托管到第三方平台(例如github, oschina) 使用环境 无论是单人开发还是多人开发,客户端都可以使用命令行或者图形界面使用git SourceTree 下载地址：http://www.sourcetreeapp.com/download/ GitHub 下载地址：https://mac.github.com不过它是专门为GitHub网站而设计的 Xcode 虽然集成较好,但是只能做一些常用的简单操作,复杂操作还要使用命令行]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建个人博客]]></title>
    <url>%2F2016%2F05%2F06%2FcreatHexo%2F</url>
    <content type="text"><![CDATA[Hexo搭建个人博客 Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds. 大致解释是:Hexo是一个快速，简单和强大的博客框架。你写的Markdown（或其他语言）的帖子Hexo在几秒钟内就能生成静态文件; 环境配置安装Hexo非常容易。但是，你需要先安装几个其他的东西： Node.js作用：用来生成静态页面的 到Node.js官网下载相应平台的最新版本，一路安装即可。官网入口 Github账号作用：用来做博客的远程创库、域名、静态资源服务器。怎么申请github的账号和ssh key等,请大家自行搜索,网络上资源还是很丰富的。 关联Github添加ssh key到Github检查SSH keys是否存在Github执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤1.3将SSH key添加到Github中，否则进入下一步生成SSH key。 1$ ls -al ~/.ssh 生成新的ssh key执行如下命令生成public/private rsa key pair，注意将`your_email@example.com`换成你自己注册Github的邮箱地址。 1$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。 将ssh key添加到Github中Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。 进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key: Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。 正式安装Hexonodejs和git都安装好后，可执行如下命令安装hexo： 1$ sudo npm install -g hexo 初始化创建一个文件夹，如：Blog，进入到Blog里分别执行init命令和安装依赖命令： 12$ hexo init blog$ npm install 生成静态页面继续再Blog目录下执行如下命令，生成静态页面: 1$ hexo generate 或 hexo g 安装hexo-server插件1$ sudo npm install hexo-server 本地启动启动本地服务，进行文章预览调试，命令： 1$ hexo server 或 hexo s 浏览器输入localhost:4000进行预览博客网站,是不是很简陋呢,但是好歹有一个自己的家园了,也是很兴奋呢。但是现在都是在本地进行的,需要和github进行关联。 配置Github建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法 然后建立关联,例如我的是:luojinghui.github.io,此时,你的目录应该是这样子: Blog ｜ ｜－－ _config.yml ｜－－ node_modules ｜－－ public ｜－－ source ｜－－ db.json ｜－－ package.json ｜－－ scaffolds ｜－－ themes 现在我们需要修改_config.yml文件，用编辑器打开,翻到最后,改成这个样子(注意冒号后面的空格): 1234deploy: type: git repository: https://github.com/liyilian/liyilian.github.io branch: master 执行如下命才能使用git部署(只需要执行一次): 1$ npm install hexo-deployer-git --save 执行这个命令进行部署: 1$ hexo deploy 然后在浏览器中输入 http://liyilian.github.io 就行了，我的 github 的账户叫 liyilian ,把这个改成你 github 的账户名就行了 备注每次部署的步骤，可按以下三步来进行: 123$ hexo clean$ hexo generate$ hexo deploy 简写: 12$ hexo clean$ hexo g -d 一些常用命令： 1234567$ hexo new &quot;postName&quot; #新建文章$ hexo new page &quot;pageName&quot; #新建页面$ hexo generate #生成静态页面至public目录$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭$ server）$ hexo deploy #将.deploy目录部署到GitHub$ hexo help #查看帮助$ hexo version #查看Hexo的版本 主题这里面有很多主题,可以参考: Hexo官网主题页 图片路径1.文章在 source/_posts下新建以.md为结尾的文件，编辑器可以用Webstrom、Sublime，支持 markdown 语法2.修改头像可以直接在主题里的 _config.yml 文件里面修改，友情链接，之类的都在这里3.创建文章的文件开头格式,可以用我现用的格式去写: 12345678910---title: 填写标题tags: - tag1- tag2date: 2016/6/06 12:20:25reward: 是否支持打赏,填写true或者falsekeywords: 关键词1 关键词2...description: 填写描述--- 4.如果想引用本地图片路径,以根路径作为起始点,就可以了。例如: /img/logo.png开始打理你的博客吧，有什么问题下面留言,我会回复的。 Q&amp;A 问：如何让文章想只显示一部分和一个 阅读全文 的按钮？答：在文章中加一个 &lt;!--more--&gt; ， &lt;!--more--&gt; 后面的内容就不会显示出来了。 问：如何添加多说评论?答：在主题里的 _config.yml中找到duoshuo:,冒号后面填写你在多说申请用的域名,例如,我申请的是liyilian.duoshuo.com,那么,在这里就填写liyilian,就好了 转载请注明原地址，liyilian的博客：https://liyilian.github.io/ 谢谢！]]></content>
      <categories>
        <category>所有文章</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>主题配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime简介]]></title>
    <url>%2F2016%2F05%2F05%2Fruntime%2F</url>
    <content type="text"><![CDATA[一、runtime简介 RunTime简称运行时。OC就是运行时机制，也就是在运行时候的一些机制，其中最主要的是消息机制。 对于C语言，函数的调用在编译的时候会决定调用哪个函数。 对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。 事实证明： 在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。 在编译阶段，C语言调用未实现的函数就会报错。 二、runtime作用1.发送消息 方法调用的本质，就是让对象发送消息。 objc_msgSend,只有对象才能发送消息，因此以objc开头. 使用消息机制前提，必须导入#import &lt;objc/message.h&gt; 消息机制简单使用 123456789101112131415161718// 创建person对象Person *p = [[Person alloc] init];// 调用对象方法 [p eat];// 本质：让对象发送消息 objc_msgSend(p, @selector(eat));// 调用类方法的方式：两种// 第一种通过类名调用[Person eat];// 第二种通过类对象调用[[Person class] eat];// 用类名调用类方法，底层会自动把类名转换成类对象调用// 本质：让类对象发送消息 objc_msgSend([Person class], @selector(eat)); 消息机制原理:对象根据方法编号SEL去映射表查找对应的方法实现 2.交换方法 开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。 方式一:继承系统的类，重写方法. 方式二:使用runtime,交换方法. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。 // 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name; // 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。 UIImage *image = [UIImage imageNamed:@"123"];&#125;@end@implementation UIImage (Image)// 加载分类到内存的时候调用+ (void)load&#123; // 交换方法 // 获取imageWithName方法地址 Method imageWithName = class_getClassMethod(self, @selector(imageWithName:)); // 获取imageWithName方法地址 Method imageName = class_getClassMethod(self, @selector(imageNamed:)); // 交换方法地址，相当于交换实现方式 method_exchangeImplementations(imageWithName, imageName);&#125;// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.// 既能加载图片又能打印+ (instancetype)imageWithName:(NSString *)name&#123; // 这里调用imageWithName，相当于调用imageName UIImage *image = [self imageWithName:name]; if (image == nil) &#123; NSLog(@"加载空的图片"); &#125; return image;&#125;@end 3.动态添加方法 开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。 经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。 简单使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. Person *p = [[Person alloc] init]; // 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。 // 动态添加方法就不会报错 [p performSelector:@selector(eat)];&#125;@end@implementation Person// void(*)()// 默认方法都有两个隐式参数，void eat(id self,SEL sel)&#123; NSLog(@"%@ %@",self,NSStringFromSelector(sel));&#125;// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if (sel == @selector(eat)) &#123; // 动态添加eat方法 // 第一个参数：给哪个类添加方法 // 第二个参数：添加方法的方法编号 // 第三个参数：添加方法的函数实现（函数地址） // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd class_addMethod(self, @selector(eat), eat, "v@:"); &#125; return [super resolveInstanceMethod:sel];&#125;@end 4.给分类添加属性 原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。 12345678910111213141516171819202122232425262728293031323334353637383940@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 给系统NSObject类动态添加属性name NSObject *objc = [[NSObject alloc] init]; objc.name = @"小码哥"; NSLog(@"%@",objc.name);&#125;@end// 定义关联的keystatic const char *key = "name";@implementation NSObject (Property)- (NSString *)name&#123; // 根据关联的key，获取关联的值。 return objc_getAssociatedObject(self, key);&#125;- (void)setName:(NSString *)name&#123; // 第一个参数：给哪个对象添加关联 // 第二个参数：关联的key，通过这个key获取 // 第三个参数：关联的value // 第四个参数:关联的策略 objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 5.字典转模型 设计模型：字典转模型的第一步 模型属性，通常需要跟字典中的key一一对应 问题：一个一个的生成模型属性，很慢？ 需求：能不能自动根据一个字典，生成对应的属性。 解决：提供一个分类，专门根据字典生成对应的属性字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243@implementation NSObject (Log)// 自动打印属性字符串+ (void)resolveDict:(NSDictionary *)dict&#123; // 拼接属性字符串代码 NSMutableString *strM = [NSMutableString string]; // 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码 [dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; // 类型经常变，抽出来 NSString *type; if ([obj isKindOfClass:NSClassFromString(@"__NSCFString")]) &#123; type = @"NSString"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFArray")])&#123; type = @"NSArray"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFNumber")])&#123; type = @"int"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFDictionary")])&#123; type = @"NSDictionary"; &#125; // 属性字符串 NSString *str; if ([type containsString:@"NS"]) &#123; str = [NSString stringWithFormat:@"@property (nonatomic, strong) %@ *%@;",type,key]; &#125;else&#123; str = [NSString stringWithFormat:@"@property (nonatomic, assign) %@ %@;",type,key]; &#125; // 每生成属性字符串，就自动换行。 [strM appendFormat:@"\n%@\n",str]; &#125;]; // 把拼接好的字符串打印出来，就好了。 NSLog(@"%@",strM); &#125; @end 字典转模型的方式一：KVC 12345678910111213 @implementation Status + (instancetype)statusWithDict:(NSDictionary *)dict &#123; Status *status = [[self alloc] init]; [status setValuesForKeysWithDictionary:dict]; return status; &#125; @end KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。 如果不一致，就会调用[ setValue:forUndefinedKey:] 报key找不到的错。 分析:模型中的属性和字典的key不一一对应，系统就会调用setValue:forUndefinedKey:报错。 解决:重写对象的setValue:forUndefinedKey:,把系统的方法覆盖， 就能继续使用KVC，字典转模型了。 1234- (void)setValue:(id)value forUndefinedKey:(NSString *)key&#123;&#125; 字典转模型的方式二：Runtime 思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。 步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 解析Plist文件 NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;status.plist&quot; ofType:nil]; NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath]; // 获取字典数组 NSArray *dictArr = statusDict[@&quot;statuses&quot;]; // 自动生成模型的属性字符串// [NSObject resolveDict:dictArr[0][@&quot;user&quot;]]; _statuses = [NSMutableArray array]; // 遍历字典数组 for (NSDictionary *dict in dictArr) &#123; Status *status = [Status modelWithDict:dict]; [_statuses addObject:status]; &#125; // 测试数据 NSLog(@&quot;%@ %@&quot;,_statuses,[_statuses[0] user]);&#125;@end@implementation NSObject (Model)+ (instancetype)modelWithDict:(NSDictionary *)dict&#123; // 思路：遍历模型中所有属性-》使用运行时 // 0.创建对应的对象 id objc = [[self alloc] init]; // 1.利用runtime给对象中的成员属性赋值 // class_copyIvarList:获取类中的所有成员属性 // Ivar：成员属性的意思 // 第一个参数：表示获取哪个类中的成员属性 // 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值 // 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。 /* 类似下面这种写法 Ivar ivar; Ivar ivar1; Ivar ivar2; // 定义一个ivar的数组a Ivar a[] = &#123;ivar,ivar1,ivar2&#125;; // 用一个Ivar *指针指向数组第一个元素 Ivar *ivarList = a; // 根据指针访问数组第一个元素 ivarList[0]; */ unsigned int count; // 获取类中的所有成员属性 Ivar *ivarList = class_copyIvarList(self, &amp;count); for (int i = 0; i &lt; count; i++) &#123; // 根据角标，从数组取出对应的成员属性 Ivar ivar = ivarList[i]; // 获取成员属性名 NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 处理成员属性名-&gt;字典中的key // 从第一个角标开始截取 NSString *key = [name substringFromIndex:1]; // 根据成员属性名去字典中查找对应的value id value = dict[key]; // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型 // 判断下value是否是字典 if ([value isKindOfClass:[NSDictionary class]]) &#123; // 字典转模型 // 获取模型的类对象，调用modelWithDict // 模型的类名已知，就是成员属性的类型 // 获取成员属性类型 NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; // 生成的是这种@&quot;@\&quot;User\&quot;&quot; 类型 -》 @&quot;User&quot; 在OC字符串中 \&quot; -&gt; &quot;，\是转义的意思，不占用字符 // 裁剪类型字符串 NSRange range = [type rangeOfString:@&quot;\&quot;&quot;]; type = [type substringFromIndex:range.location + range.length]; range = [type rangeOfString:@&quot;\&quot;&quot;]; // 裁剪到哪个角标，不包括当前角标 type = [type substringToIndex:range.location]; // 根据字符串类名生成类对象 Class modelClass = NSClassFromString(type); if (modelClass) &#123; // 有对应的模型才需要转 // 把字典转模型 value = [modelClass modelWithDict:value]; &#125; &#125; // 三级转换：NSArray中也是字典，把数组中的字典转换成模型. // 判断值是否是数组 if ([value isKindOfClass:[NSArray class]]) &#123; // 判断对应类有没有实现字典数组转模型数组的协议 if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123; // 转换成id类型，就能调用任何对象的方法 id idSelf = self; // 获取数组中字典对应的模型 NSString *type = [idSelf arrayContainModelClass][key]; // 生成模型 Class classModel = NSClassFromString(type); NSMutableArray *arrM = [NSMutableArray array]; // 遍历字典数组，生成模型数组 for (NSDictionary *dict in value) &#123; // 字典转模型 id model = [classModel modelWithDict:dict]; [arrM addObject:model]; &#125; // 把模型数组赋值给value value = arrM; &#125; &#125; if (value) &#123; // 有值，才需要给模型的属性赋值 // 利用KVC给模型中的属性赋值 [objc setValue:value forKey:key]; &#125; &#125; return objc; &#125; @end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
</search>
